<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çº¯å‰ç«¯ EPUB è½¬ PDF å·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* åŠ è½½åŠ¨ç”»æ ·å¼ */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-8 font-sans">
    <div class="max-w-2xl mx-auto bg-white p-8 rounded-2xl shadow-lg">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">ğŸ“š EPUB è½¬ PDF è½¬æ¢å™¨</h1>
            <p class="text-sm text-gray-500 bg-yellow-50 p-3 rounded-lg border border-yellow-200 inline-block text-left">
                <span class="font-bold">âš ï¸ æŠ€æœ¯è¯´æ˜ï¼š</span><br>
                è¿™æ˜¯ä¸€ä¸ªçº¯æµè§ˆå™¨ç«¯çš„è½¬æ¢å·¥å…·ã€‚ä¸ºäº†æ€§èƒ½å’Œç¨³å®šæ€§ï¼Œå®ƒä¸»è¦æå–æ–‡æœ¬å†…å®¹ã€‚å¤æ‚çš„ CSS å¸ƒå±€ã€å›¾ç‰‡æ’ç‰ˆå’Œè‡ªå®šä¹‰å­—ä½“å¯èƒ½ä¼šåœ¨è½¬æ¢åçš„ PDF ä¸­ä¸¢å¤±ã€‚é€‚ç”¨äºæ–‡å­—ä¸ºä¸»çš„ä¹¦ç±ã€‚
            </p>
        </header>

        <div class="space-y-6">
            <div class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:border-blue-500 transition-colors bg-gray-50" id="dropZone">
                <input type="file" id="fileInput" accept=".epub" class="hidden">
                <label for="fileInput" class="cursor-pointer flex flex-col items-center justify-center">
                    <svg class="w-12 h-12 text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                    </svg>
                    <span class="text-gray-600 font-medium">ç‚¹å‡»é€‰æ‹©æˆ–æ‹–æ‹½ EPUB æ–‡ä»¶è‡³æ­¤</span>
                    <span class="text-sm text-gray-400 mt-1" id="fileNameDisplay"></span>
                </label>
            </div>

            <button id="convertBtn" disabled class="w-full py-4 bg-blue-600 text-white rounded-xl font-bold text-lg shadow-md hover:bg-blue-700 focus:ring-4 focus:ring-blue-300 transition-all disabled:bg-gray-400 disabled:cursor-not-allowed flex justify-center items-center">
                å¼€å§‹è½¬æ¢
            </button>

            <div id="statusArea" class="hidden mt-6 p-4 bg-blue-50 rounded-xl border border-blue-100">
                <div class="flex items-center mb-3">
                    <div class="loader mr-3" id="loadingSpinner"></div>
                    <h3 class="font-semibold text-blue-800" id="statusTitle">æ­£åœ¨å¤„ç†...</h3>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700 mb-2">
                    <div class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%" id="progressBar"></div>
                </div>
                <p class="text-sm text-blue-600" id="statusText">å‡†å¤‡ä¸­...</p>
                <div id="logArea" class="mt-4 p-3 bg-gray-800 text-green-400 font-mono text-xs rounded-lg h-32 overflow-y-auto hidden"></div>
            </div>
        </div>
    </div>

    <script>
        // ç¡®ä¿ jsPDF æ­£ç¡®åŠ è½½
        const { jsPDF } = window.jspdf;

        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const convertBtn = document.getElementById('convertBtn');
        const statusArea = document.getElementById('statusArea');
        const statusTitle = document.getElementById('statusTitle');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const logArea = document.getElementById('logArea');

        let selectedFile = null;
        let pdfDoc = null;

        // --- UI äº¤äº’é€»è¾‘ ---
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                selectedFile = e.target.files[0];
                fileNameDisplay.textContent = `å·²é€‰æ‹©: ${selectedFile.name}`;
                convertBtn.disabled = false;
                resetStatus();
            }
        });

        // æ‹–æ‹½æ”¯æŒ
        const dropZone = document.getElementById('dropZone');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        dropZone.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files[0] && files[0].name.endsWith('.epub')) {
                fileInput.files = files;
                selectedFile = files[0];
                fileNameDisplay.textContent = `å·²é€‰æ‹©: ${selectedFile.name}`;
                convertBtn.disabled = false;
                resetStatus();
            } else {
                alert('è¯·æ”¾å…¥ .epub æ–‡ä»¶');
            }
        });

        convertBtn.addEventListener('click', startConversion);

        
		// --- æ ¸å¿ƒè½¬æ¢é€»è¾‘ï¼ˆæ·±åº¦ä¿®å¤ç‰ˆï¼‰ ---

async function startConversion() {
    if (!selectedFile) return;
    
    convertBtn.disabled = true;
    statusArea.classList.remove('hidden');
    loadingSpinner.classList.remove('hidden');
    statusTitle.textContent = "æ­£åœ¨æå–æ–‡æœ¬å†…å®¹...";
    logArea.classList.remove('hidden');
    logArea.innerHTML = '';

    try {
        pdfDoc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
        const reader = new FileReader();

        reader.onload = async function(e) {
            const book = ePub(e.target.result);
            await book.ready;
            
            const sections = book.spine.spineItems;
            const totalItems = sections.length;
            log(`æˆåŠŸåŠ è½½ EPUBï¼Œå…± ${totalItems} ä¸ªå†…å®¹å—ã€‚`);

            let isFirstPage = true;

            for (let i = 0; i < totalItems; i++) {
                const section = sections[i];
                updateProgress(10 + Math.round((i / totalItems) * 85), `å¤„ç†è¿›åº¦: ${i + 1}/${totalItems}`);

                try {
                    // åŠ è½½ç« èŠ‚å†…å®¹
                    const content = await section.load(book.load.bind(book));
                    
                    // --- ä¿®å¤é€»è¾‘ï¼šæ™ºèƒ½æå–æ–‡æœ¬ ---
                    let cleanText = "";
                    
                    if (typeof content === 'string') {
                        // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œè§£æå®ƒ
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(content, "text/html");
                        cleanText = doc.body.innerText || doc.body.textContent || "";
                    } else if (content instanceof Document) {
                        // å¦‚æœç›´æ¥æ˜¯ Document å¯¹è±¡
                        cleanText = content.body.innerText || content.body.textContent || "";
                    } else if (content instanceof HTMLElement) {
                        // å¦‚æœæ˜¯ HTML èŠ‚ç‚¹
                        cleanText = content.innerText || content.textContent || "";
                    }

                    // æ¸…ç†å¤šä½™ç©ºæ ¼å’Œæ¢è¡Œ
                    cleanText = cleanText.replace(/\s+/g, ' ').trim();

                    if (cleanText.length > 5) { // è¿‡æ»¤æ‰åªæœ‰å‡ ä¸ªå­—ç¬¦çš„æ— æ•ˆç‰‡æ®µ
                        if (!isFirstPage) pdfDoc.addPage();

                        // å°è¯•è·å–ç« èŠ‚å
                        const chapterTitle = findChapterTitle(section, book.navigation);
                        let currentY = 20;

                        if (chapterTitle) {
                            pdfDoc.setFont(undefined, 'bold');
                            const titleLines = pdfDoc.splitTextToSize(chapterTitle, 180);
                            pdfDoc.text(titleLines, 15, currentY);
                            currentY += (titleLines.length * 8) + 5;
                            pdfDoc.setFont(undefined, 'normal');
                        }

                        // å†™å…¥ PDF
                        writeMultiPageText(pdfDoc, cleanText, 15, currentY);
                        isFirstPage = false;
                        
                        if ((i + 1) % 20 === 0) log(`å·²å¤„ç†è‡³ ${i + 1} ç« ...`);
                    }
                } catch (chapterErr) {
                    console.warn(`ç« èŠ‚ ${i} å¤„ç†å¼‚å¸¸:`, chapterErr);
                }

                // é˜²æ­»é”
                if (i % 15 === 0) await new Promise(r => setTimeout(r, 5));
            }

            log("æ­£åœ¨ç”Ÿæˆæœ€ç»ˆæ–‡ä»¶...");
            const outputName = selectedFile.name.replace(/\.epub$/i, '.pdf');
            pdfDoc.save(outputName);
            
            statusTitle.textContent = "è½¬æ¢å®Œæˆï¼";
            loadingSpinner.classList.add('hidden');
            convertBtn.disabled = false;
        };
        reader.readAsArrayBuffer(selectedFile);

    } catch (err) {
        log(`è‡´å‘½é”™è¯¯: ${err.message}`, true);
        convertBtn.disabled = false;
    }
}
		
		
        // --- è¾…åŠ©å‡½æ•° ---

        function updateProgress(percent, text) {
            progressBar.style.width = `${percent}%`;
            statusText.textContent = text;
        }

        function resetStatus() {
            statusArea.classList.add('hidden');
            progressBar.style.width = '0%';
            statusTitle.classList.remove('text-red-600');
            statusTitle.textContent = 'æ­£åœ¨å¤„ç†...';
            logArea.innerHTML = '';
        }

        function log(msg, isError = false) {
            const p = document.createElement('p');
            p.textContent = `> ${msg}`;
            if (isError) p.style.color = '#ef4444';
            logArea.appendChild(p);
            logArea.scrollTop = logArea.scrollHeight;
        }

        // å°è¯•åœ¨å¯¼èˆªç›®å½•ä¸­æŸ¥æ‰¾ç« èŠ‚æ ‡é¢˜
        function findChapterTitle(item, navigation) {
            if (!navigation || !navigation.toc) return null;
            
            // é€’å½’æŸ¥æ‰¾ç›®å½•æ ‘
            function searchToc(tocItems) {
                for (const tocItem of tocItems) {
                    // æ£€æŸ¥ href æ˜¯å¦åŒ¹é…å½“å‰ spine item çš„ href
                    // éœ€è¦å¤„ç† href ä¸­å¯èƒ½å¸¦æœ‰çš„é”šç‚¹ (ä¾‹å¦‚ chapter1.html#section2)
                    const tocHrefClean = tocItem.href.split('#')[0];
                    const itemHrefClean = item.href.split('#')[0];

                    if (tocHrefClean === itemHrefClean) {
                        return tocItem.label.trim();
                    }
                    if (tocItem.subitems && tocItem.subitems.length > 0) {
                        const found = searchToc(tocItem.subitems);
                        if (found) return found;
                    }
                }
                return null;
            }
            return searchToc(navigation.toc);
        }

        // æ ¸å¿ƒéš¾é¢˜è§£å†³ï¼šå°†é•¿æ–‡æœ¬å†™å…¥ PDF å¹¶è‡ªåŠ¨åˆ†é¡µ
        function writeMultiPageText(doc, text, x, y) {
            const lineHeight = 7; // è¡Œé«˜ mm
            const pageHeight = doc.internal.pageSize.height; // A4 é«˜åº¦é€šå¸¸æ˜¯ 297mm
            const margin = 20; // åº•éƒ¨è¾¹è·
            const maxLineWidth = 190; // A4 å®½åº¦ 210 - å·¦å³è¾¹è· 10*2

            // jsPDF çš„æ ¸å¿ƒæ–¹æ³•ï¼šå°†é•¿æ–‡æœ¬æ‹†åˆ†ä¸ºé€‚åº”å®½åº¦çš„è¡Œæ•°ç»„
            const splitText = doc.splitTextToSize(text, maxLineWidth);

            let cursorY = y;

            for (let i = 0; i < splitText.length; i++) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ†é¡µ
                if (cursorY + lineHeight > pageHeight - margin) {
                    doc.addPage();
                    cursorY = 20; // æ–°é¡µé¢çš„èµ·å§‹ Y åæ ‡
                }
                doc.text(splitText[i], x, cursorY);
                cursorY += lineHeight;
            }
        }

    </script>
</body>
</html>